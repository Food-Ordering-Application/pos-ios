//
//  OrdersPageInteractor.swift
//  smartPOS
//
//  Created by I Am Focused on 17/04/2021.
//  Copyright (c) 2021 Clean Swift LLC. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import PromiseKit
import UIKit
import SwiftEventBus
struct RTDataOrder: Decodable {
    let order: RTOrderStatus?
}
struct RTOrderStatus: Decodable {
    let id: String?
    let status: OrderStatus?
}

protocol OrdersPageBusinessLogic {
    func fetchOrders(request: OrdersPage.FetchOrders.Request)
    func fetchSearchOrders(request: OrdersPage.SearchOrders.Request)
    func fetchOrdersByStatus(request: OrdersPage.FetchOrdersByStatus.Request)
    func refreshOrders(request: OrdersPage.RefreshOrders.Request)
}

protocol OrdersPageDataStore {
    var orders: [Order]? { get set }
}

final class OrdersPageInteractor: OrdersPageBusinessLogic, OrdersPageDataStore {
    var presenter: OrdersPagePresentationLogic?
    var worker = OrdersPageWorker()
    var orders: [Order]?

    init() {
        SwiftEventBus.onMainThread(self, name: "RTOrderStatus") { result in
            let newOrder = result?.object as? RTOrderStatus
            guard var orders = self.orders else { return }
            if let row = orders.index(where: {$0.id == newOrder?.id}) {
                orders[row].status = newOrder?.status
                print("ðŸ†‘ ðŸ†‘ ðŸ†‘ ðŸ†‘ ðŸ†‘ RTOrderStatus ðŸ†‘ ðŸ†‘ ðŸ†‘ ðŸ†‘ ðŸ†‘")
                self.orders = orders
                self.onUpdateOrders(orders: orders)
            }
        }
    }
    
    // MARK: Handle for realtime
    func onUpdateOrders(orders: Orders?) {
        let response = OrdersPage.FetchOrders.Response(orders: orders, error: nil)
        presenter?.presentOrders(response: response)
    }
    // MARK: Fetchs launch to display during page loading

    func fetchOrders(request: OrdersPage.FetchOrders.Request) {
        let restaurantId = request.restaurantId
        let query = request.query
        let pageNumber = request.pageNumber

        var response: OrdersPage.FetchOrders.Response!

        worker.ordersDataManager.getOrders(restaurantId: restaurantId, query: query, pageNumber: pageNumber).done { ordersRes in
            if ordersRes.statusCode >= 200 || ordersRes.statusCode <= 300 {
                let data = ordersRes.data
                self.orders = data.orders
                response = OrdersPage.FetchOrders.Response(orders: data.orders, error: nil)
            }
            
        }.catch { error in
            response = OrdersPage.FetchOrders.Response(orders: nil, error: OrderErrors.couldNotLoadOrders(error: error.localizedDescription))
        }.finally {
            self.presenter?.presentOrders(response: response)
        }
    }

    // MARK: Fetch launches based on a search query

    func fetchSearchOrders(request: OrdersPage.SearchOrders.Request) {
        let filteredLaunches = getFilteredSearchedOrders(orders, query: request.query, orderStatus: request.orderStatus)
        let response = OrdersPage.SearchOrders.Response(orders: filteredLaunches)
        presenter?.presentSearchedOrders(response: response)
    }

    // MARK: Fetch launches based on a launch type

    func fetchOrdersByStatus(request: OrdersPage.FetchOrdersByStatus.Request) {
        let filteredOrders = getFilteredByStatusOrders(orders, orderStatus: request.orderStatus)
        let response = OrdersPage.FetchOrdersByStatus.Response(orders: filteredOrders)
        presenter?.presentSearchedOrdersByStatus(response: response)
    }

    // MARK: Refresh launches

    func refreshOrders(request: OrdersPage.RefreshOrders.Request) {
        let restaurantId = request.restaurantId
        let query = request.query
        let pageNumber = request.pageNumber

        var response: OrdersPage.RefreshOrders.Response!

        worker.ordersDataManager.getOrders(restaurantId: restaurantId, query: query, pageNumber: pageNumber).done { ordersRes in
            print(ordersRes.data)
            if ordersRes.statusCode >= 200 || ordersRes.statusCode <= 300 {
                let data = ordersRes.data
                response = OrdersPage.RefreshOrders.Response(orders: data.orders, error: nil)
            }
        }.catch { error in
            response = OrdersPage.RefreshOrders.Response(orders: nil, error: OrderErrors.couldNotLoadOrders(error: error.localizedDescription))
        }.finally {
            self.presenter?.presentRefreshedOrders(response: response)
        }
    }
}

extension OrdersPageInteractor {
    /// Gets the filtered launches based on type
    ///
    /// - Parameters:
    ///   - launches: All the launches
    ///   - typeOfLaunches: The type of launch to display (passed or upcoming)
    /// - Returns: Return a filtered array of launches
    private func getFilteredByStatusOrders(_ orders: [Order]?, orderStatus: OrderStatus = .confirmed) -> [Order] {
        guard let orders = orders else { return [] }
//        let isUpcommingOrder = orderStatus == .delivering ? false : true
//        return orders.filter { $0.status == orderStatus }
        return orders
    }

    /// Get the filtered launches based on a query search
    ///
    /// - Parameters:
    ///   - launches: All the launches
    ///   - query: The query to apply for search
    ///   - typeOfLaunch: The typpe of launches to apply the search to
    /// - Returns: Return a filtered array based on type & query
    private func getFilteredSearchedOrders(_ orders: [Order]?, query: String?, orderStatus: OrderStatus) -> [Order] {
        guard let orders = orders else { return [] }
        let filteredOrders = getFilteredByStatusOrders(orders, orderStatus: orderStatus)
        guard let searchText = query, !searchText.isEmpty else { return filteredOrders }
        return filteredOrders
    }
}
